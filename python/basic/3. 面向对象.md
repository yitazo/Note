## 类和对象

和java基本一样，有以下不同

- 没有静态属性和方法
- 属性和方法没有访问权限修饰符，默认都是公开，前面加两下划线就变为私有的了
- 可以随意设置不存在的属性
- 方法必须写一个self参数，这个参数不用自己传，功能相当于this，必须通过self.才能访问到自身属性
- 没有new关键字，直接构造方法()即可返回对象
- 其余构造方法变成init，toString -> str，equals -> eq，hashcode -> hash，注意这些方法前后都有两下划线。==比较的也是内存地址，重写eq也必须重写hash这点和java的原因一样

### 封装

使用两个下划线变为私有的

### 继承

通过 (父类名) 完成继承，如果继承之后不想写新功能，可以在类中使用pass关键字。python是多继承的

- 多继承使用(父类名1, 父类名2, ..., 父类名n)
- 多继承中，如果有同名的属性和方法，谁先继承就是谁的
- py没有方法重载，名称相同的话后面的方法会覆盖前面的

#### 重写方法

和java有以下不一样

- python重写时，方法名字和父类的相同就可以，参数和返回值类型可以不一样（因为就没有类型），数量可以不同
- 因为默认抛出异常，也没有不可以抛出更多异常这一说
- 因为没有访问权限修饰符，所有也没有访问权限不能更低。两下划线变成私有名字都不一样所以不算重写
- 在子类中访问父类的成员变量和方法时，使用父类名.方法或者super().方法，调用方法时如果使用父类名需要把self当参数传入

### 多态

跟java一样，子类重写父类方法，方法中形参是父类变量，然后传入子类，调用父类中被子类重写了的方法，运行时产生不同状态

- 方法中只写pass则该方法为抽象方法，带有抽象方法的类就是抽象类，py中没有接口的概念抽象类就是接口
- py中子类可以不实现抽象方法，调用时返回None

## 类型注解

类型注解只是方便自己看和让编译器给出提示用，并不是强制要该类型，不用该类型也没问题

### 使用

```python
from typing import List, Tuple

# 3.5及以后才有的功能，无法当作泛型使用，但是可以让编译器有提示
my_int: int = 666
my_dict: dict = {"py": 666}
# 详细类型注解，py3.8中必须大写类并且导报包，详细注解之后取出列表元素，该元素.也有方法提示了因为标记是str
my_list: List[str] = ["666"]

my_str = "1"  # type: str
my_tuple = ("py", "666")  # type: Tuple


# 形参和返回值类型也能标记
def add(x: int, y: int = 999) -> int:
    return x + y
```

### Union

当该变量或形参或返回值类型有可能有多种类型的时候，可以使用Union[type1, type2, ..., typen]来标记，注意Union也需要导入

```python
from typing import Union
var1: List[Union[str, int]] = ["py", 666]
var2: Union[list, str] = "py"


# 形参和返回值类型也可以Union标记
def add_update(x: Union[int, float], y: [int, float] = 999) -> Union[int, float]:
    return x + y
```